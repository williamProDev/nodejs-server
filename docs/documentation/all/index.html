<!DOCTYPE html><html class="initial"><head><title>Full documentation - server.js</title><meta property="og:title" content="Full documentation - server.js"/><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="server, javascript, js, node.js, library, html, html5, express"><meta name="description" content="Full documentation for server.js"/><meta property="og:description" content="Full documentation for server.js"/><link rel="shortcut icon" type="image/png" href="/img/logo.png"><meta property="og:url" content="http://serverjs.io/"><meta property="og:image" content="https://serverjs.io/img/logo.png"><link href="/assets/style.min.css" rel="stylesheet"></head><body><nav class="instant transparent"><a class="brand" href="/"><img class="logo" src="/img/logo.svg" alt="logo"><span class="text">server.js</span></a><input class="show" id="bmenu" type="checkbox"><label class="burger pseudo button switch" for="bmenu">menu</label><div class="menu"><a class="pseudo button" href="/sponsor">Sponsor</a><a class="pseudo button" href="https://medium.com/server-for-node-js" target="_blank">Blog</a><a class="pseudo button" href="https://github.com/franciscop/server" target="_blank">Github</a><a class="pseudo button" href="/tutorials">Tutorials</a><a class="button" href="/documentation">Documentation</a></div></nav><div class="hero"><div class="content"><h1> <strong>Documentation</strong></h1></div></div><article class="documentation"><div class="flex one three-700 four-1000"><div class="full third-700 fourth-1000"><section class="toc"><a href="/documentation/all/"><h2>Documentation</h2></a><ul><li><label class="more">›</label><a href="/documentation/all/#options">Options</a><ul><li><a href="/documentation/all/#port"><code>port</code></a></li><li><a href="/documentation/all/#secret"><code>secret</code></a></li><li><a href="/documentation/all/#public"><code>public</code></a></li><li><a href="/documentation/all/#views"><code>views</code></a></li><li><a href="/documentation/all/#engine"><code>engine</code></a></li><li><a href="/documentation/all/#env"><code>env</code></a></li><li><a href="/documentation/all/#log"><code>log</code></a></li><li><a href="/documentation/all/#core"><code>core</code></a></li></ul></li><li><label class="more">›</label><a href="/documentation/all/#middleware">Middleware</a><ul><li> <a href="/documentation/all/#parameters">Parameters [TBD]</a></li><li> <a href="/documentation/all/#context">Context</a></li><li> <a href="/documentation/all/#synchronous">Synchronous</a></li><li> <a href="/documentation/all/#asynchronous">Asynchronous</a></li><li> <a href="/documentation/all/#express-middleware">From express.js</a></li></ul></li><li><label class="more">›</label><a href="/documentation/all/#router">Router</a><ul class="size-100"><li><a href="/documentation/all/#rest">get()</a></li><li><a href="/documentation/all/#rest">post()</a></li><li><a href="/documentation/all/#rest">put()</a></li><li><a href="/documentation/all/#rest">del()</a></li><li><a href="/documentation/all/#error">error()</a></li><li><a href="/documentation/all/#websockets">socket()</a></li><li><a href="/documentation/all/#">sub() [TBD]</a></li></ul></li><li><label class="more">›</label><a href="#">Reply [TBD]</a><ul><li><a href="#">cookie() [TBD]</a></li><li><a href="#">download() [TBD]</a></li><li><a href="#">end() [TBD]</a></li><li><a href="#">file() [TBD]</a></li><li><a href="#">header() [TBD]</a></li><li><a href="#">json() [TBD]</a></li><li><a href="#">jsonp() [TBD]</a></li><li><a href="#">redirect() [TBD]</a></li><li><a href="#">render() [TBD]</a></li><li><a href="#">send() [TBD]</a></li><li><a href="#">status() [TBD]</a></li><li><a href="#">type() [TBD]</a></li></ul></li><li><label class="more">›</label><a href="#">Errors [TBD]</a><ul><li><a href="#">PortAlreadyUsed [TBD]</a></li><li><a href="#">MissingMiddleware [TBD]</a></li><li><a href="#">InvalidMiddleware [TBD]</a></li></ul></li><li><label class="more">›</label><a href="/documentation/all/#advanced">Advanced</a><ul><li><a href="/documentation/all/#creating-middleware">Write middleware</a></li><li><a href="/documentation/all/#">Write plugins [TBD]</a></li><li><a href="/documentation/all/#">Contributing [TBD]</a></li></ul></li></ul></section></div><div class="full two-third-700 three-fourth-1000">
<p>Conceptually <strong>server</strong> is a function that accepts options and other functions. The heavy lifting is already implemented <strong>so you can focus on your project</strong>:</p>
<pre><code class="lang-js">// Import the variable into the file
const server = require(&#39;server&#39;);

// options and fn1, fn2, etc are optional
server(options, fn1, fn2, fn3, ...);
</code></pre>
<p>The most important concepts to use server are: <a href="options"><strong>options</strong></a>, <a href="middleware"><strong>middleware</strong></a> and <a href="router"><strong>router</strong></a>. You might also want to learn by doing <a href="/tutorials"><strong>real-world examples in the tutorials</strong></a>.</p>
<h2 id="-options-options-"><a href="options">Options</a></h2>
<p>In its basic form it&#39;s a plain object with several key:values pairs:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

// Set the options (shown here with the defaults)
const options = {
  port: 3000
  secret: &#39;secret-XXXX&#39;
  public: &#39;public&#39;
  engine: &#39;pug&#39;
  env: &#39;development&#39;
};

// Launch the server with the options
server(options);
</code></pre>
<p><a class="button" href="options"><strong>Options documentation</strong></a></p>
<h2 id="-middleware-middleware-"><a href="middleware">Middleware</a></h2>
<p>Middleware are functions that accepts a context, does some work and is resolved either synchronous or asynchronous. Mandatory <em>Hello World</em> here:</p>
<pre><code class="lang-js">// Load the server from the dependencies
const server = require(&#39;server&#39;);

// Display &quot;Hello 世界&quot; for any request
const middleware = ctx =&gt; &#39;Hello 世界&#39;;

// Launch the server with a single middleware
server(middleware);
</code></pre>
<p><a class="button" href="middleware"><strong>Middleware documentation</strong></a></p>
<h2 id="-router-router-"><a href="router">Router</a></h2>
<p>The last but maybe most important part is the router that is used to create routes. A route is really a middleware and is used for handling user requests to specific places:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

// Import some of the routers available
const { get, post, put, del } = server.router;

// Handle requests to http://localhost:3000/
const home = get(&#39;/&#39;, ctx =&gt; &#39;Homepage!&#39;);

// Handle requests to http://localhost:3000/SOMETHING
const page = get(&#39;/:page&#39;, ctx =&gt; `Page ${ctx.req.params.page}`);

server(home, page);
</code></pre>
<p><a class="button" href="router"><strong>Router documentation</strong></a></p>
<h2 id="-advanced-advanced-"><a href="advanced">Advanced</a></h2>
<p>Some recommendations on using and debugging server. A peak into the technology inside for understanding it better. Explanation on some of the design constrains for server.</p>
<p><a class="button" href="advanced"><strong>Advanced documentation</strong></a></p>
<h2 id="options">Options</h2>
<p>These are the available options, their defaults, types and how to specify them in <code>.env</code>:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>default</th>
<th><a href="#environment">.env</a></th>
<th>main type</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#port"><code>port</code></a></td>
<td><code>3000</code></td>
<td><code>PORT=3000</code></td>
<td>Number</td>
</tr>
<tr>
<td><a href="#secret"><code>secret</code></a></td>
<td><code>&#39;secret-XXXX&#39;</code></td>
<td><code>SECRET=secret-XXXX</code></td>
<td>String</td>
</tr>
<tr>
<td><a href="#public"><code>public</code></a></td>
<td><code>&#39;public&#39;</code></td>
<td><code>PUBLIC=public</code></td>
<td>String</td>
</tr>
<tr>
<td><a href="#views"><code>views</code></a></td>
<td><code>&#39;views&#39;</code></td>
<td><code>VIEWS=views</code></td>
<td>String</td>
</tr>
<tr>
<td><a href="#engine"><code>engine</code></a></td>
<td><code>&#39;pug&#39;</code></td>
<td><code>ENGINE=pug</code></td>
<td>String</td>
</tr>
<tr>
<td><a href="#env"><code>env</code></a></td>
<td><code>&#39;development&#39;</code></td>
<td><strong><code>NODE_ENV=development</code></strong></td>
<td>String</td>
</tr>
<tr>
<td><a href="#log"><code>log</code></a></td>
<td><code>&#39;info&#39;</code></td>
<td><code>LOG=info</code></td>
<td>String</td>
</tr>
<tr>
<td><a href="#core"><code>core</code></a></td>
<td><a href="#core">[info]</a></td>
<td><a href="#core">[info]</a></td>
<td>Object</td>
</tr>
</tbody>
</table>
<p>And many more! <a href="https://github.com/franciscop/server/tree/master/docs/documentation/options">Help us editing this</a>.</p>
<p>The options preference order is this, from more important to less:</p>
<ol>
<li><code>.env</code>: the variable <a href="#environment">within the environment</a>.</li>
<li><code>server({ OPTION: 3000 })</code>: the variable <a href="#parameter">set as a parameter</a> when launching the server.</li>
<li><em>defaults</em>: defaults will be used as can be seen below</li>
</ol>
<p>They are accessible for your dev needs through <code>ctx.options</code> (<a href="../middleware">read more in Middleware</a>):</p>
<pre><code class="lang-js">server(ctx =&gt; console.log(ctx.options));
// { port: 3000, public: &#39;./public&#39;, ... }
</code></pre>
<h2 id="environment">Environment</h2>
<p>Environment variables are <em>not commited in your version control</em> but instead they are provided by the machine or Node.js process. In this way these options can be different in your machine and in testing, production or other type of servers.</p>
<p>They are uppercase and they can be set through a file called literally <code>.env</code> in your root folder:</p>
<pre><code>PORT=3000
PUBLIC=public
SECRET=secret-XXXX
ENGINE=pug
NODE_ENV=development
</code></pre><blockquote>
<p>Remember to <strong>add <code>.env</code> to your <code>.gitignore</code></strong>.</p>
</blockquote>
<p>To set them in remote server it will depend on the hosting that you use (<a href="https://devcenter.heroku.com/articles/config-vars">see Heroku example</a>).</p>
<h2 id="parameter">Parameter</h2>
<p>The alternative to the environment variables is to pass them <strong>as the first parameter</strong> when calling <code>server()</code>. Each option is a combination of key/value in the object and they all go in lowercase. See some options with their defaults:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

server({
  port: 3000,
  public: &#39;public&#39;,
  secret: &#39;secret-XXXX&#39;,
  engine: &#39;pug&#39;,
  env: &#39;development&#39;   // Remember this is &quot;env&quot; and not &quot;node_env&quot; here
});
</code></pre>
<h2 id="special-cases">Special cases</h2>
<p>As a general rule, an option that is an object becomes a <code>_</code> separated string in uppercase for the <code>.env</code> file. For example, for the SSL we have to pass an object such as:</p>
<pre><code class="lang-js">server({
  port: 3000,
  ssl: {
    key: &#39;./ssl.pem&#39;,
    cert: &#39;./ssl.cert&#39;
  }
});
</code></pre>
<p>So if we want to put this in the environment variable we&#39;d set it up such as:</p>
<pre><code>PORT=3000
SSL_KEY=test/fixtures/keys/agent2-key.pem
SSL_CERT=test/fixtures/keys/agent2-cert.cert
</code></pre><p>The converse is not true; a <code>_</code> separated string in the <code>.env</code> does not necessarily become an object as a parameter. You&#39;ll have to read the documentation of each option and plugin for the specific details.</p>
<h2 id="available-options">Available options</h2>
<p>Description of all the available options, their defaults and how to use them.</p>
<h3 id="port">Port</h3>
<p>The port where you want to launch the server. Defaults to <code>3000</code> and it&#39;s the only option that can be specified as a single option:</p>
<pre><code class="lang-js">server();        // Use the default port 3000
server(3000);    // Specify the port
server({ port: 3000 });  // The same as the previous one
</code></pre>
<p>Some hosts such as Heroku will define an environment variable called <code>PORT</code>, so it will work smoothly there. You can also set it instead in your <code>.env</code> if you prefer it:</p>
<pre><code>PORT=3000
</code></pre><h3 id="secret">Secret</h3>
<p>It is <a href="https://github.com/franciscop/server/issues/3"><strong>highly recommended</strong></a> that you set this in your environment variable for both development and production before you start coding. It should be a random and long string. It will be used by several middleware for storing secrets and keeping cookies/sessions:</p>
<pre><code>SECRET=your-random-string-here
</code></pre><blockquote>
<p>Note: the <em>default</em> provided is weak as it will be different each time the server is launched.</p>
</blockquote>
<h3 id="public">Public</h3>
<p>The folder where your static assets are. This includes images, styles, javascript for the browser, etc. Any file that you want directly accessible through <code>example.com/myfile.pdf</code> should be in this folder. You can set it to any folder within your project.</p>
<p>To set the public folder in the environment add this to <a href="#environment">your <code>.env</code></a>:</p>
<pre><code>PUBLIC=./public
</code></pre><p>Through the initialization parameter:</p>
<pre><code class="lang-js">server({ public: &#39;./public&#39; });
</code></pre>
<p>To set the root folder specify it as <code>&#39;./&#39;</code>:</p>
<pre><code class="lang-js">server({ public: &#39;./&#39; });
</code></pre>
<p>If you don&#39;t want any of your files to be accessible publicly, then you can cancel it through a false or empty value:</p>
<pre><code class="lang-js">server({ public: false });
server({ public: &#39;&#39; });
</code></pre>
<h3 id="views">Views</h3>
<p>The folder where your views and templates are. These are the files used by the <code>render()</code> function. You can set it to any folder within your project.</p>
<p>To set the views folder in the environment add this to <a href="#environment">your <code>.env</code></a>:</p>
<pre><code>VIEWS=./views
</code></pre><p>Through the initialization parameter:</p>
<pre><code class="lang-js">server({ views: &#39;./views&#39; });
</code></pre>
<p>To set the root folder specify it as <code>&#39;./&#39;</code>:</p>
<pre><code class="lang-js">server({ views: &#39;./&#39; });
</code></pre>
<p>It defaults to <code>views</code>; however if you don&#39;t have any view file you don&#39;t have to create the folder. The files within <code>views</code> should all have an extension such as <code>.hbs</code>, <code>.pug</code>, etc. To see how to install and use those keep reading.</p>
<h3 id="engine">Engine</h3>
<p>The view engine that you want to use to render your templates. <a href="https://github.com/expressjs/express/wiki#template-engines">See all the available engines</a>. To use an engine you normally have to install it first except for the pre-installed ones <a href="https://pugjs.org/">pug</a> and <a href="http://handlebarsjs.com/">handlebars</a>:</p>
<pre><code>npm install [ejs|nunjucks|emblem] --save
</code></pre><p>Then to use that engine you just have to add the extension to the <code>render()</code> method:</p>
<pre><code class="lang-js">// No need to specify the engine if you are using the extension
server(ctx =&gt; render(&#39;index.pug&#39;));
server(ctx =&gt; render(&#39;index.hbs&#39;));
// ...
</code></pre>
<p>However if you want to use it without extension, you can do so by specifying the engine in <code>.env</code>:</p>
<pre><code>ENGINE=pug
</code></pre><p>Or through the corresponding option in javascript:</p>
<pre><code class="lang-js">server({ engine: &#39;pug&#39; }, ctx =&gt; render(&#39;index&#39;));
</code></pre>
<h3 id="env">Env</h3>
<p>Define the context in which the server is running. The most common and accepted cases are <code>&#39;development&#39;</code>, <code>&#39;test&#39;</code> and <code>&#39;production&#39;</code>. Some functionality might vary depending on the environment, such as live/hot reloading, cache, etc.</p>
<blockquote>
<p>Note! The environment variable is called <strong>NODE_ENV</strong> while the option as a parameter is <strong>env</strong>.</p>
</blockquote>
<p>This variable does not really make sense as a parameter to the main function, so we&#39;ll normally use this within our <code>.env</code> file. See it here with the <em>default <code>development</code></em>:</p>
<pre><code>NODE_ENV=development
</code></pre><p>Then in your hosting environment you&#39;d set it to production (some hosts like Heroku do so automatically):</p>
<pre><code>NODE_ENV=production
</code></pre><h3 id="log">Log</h3>
<p>Display some data that might be of value for the developers. This includes from just some information up to really important bugs and errors notifications.</p>
<p>You can set <a href="https://www.npmjs.com/package/log#log-levels">several log levels</a> and it <strong>defaults to &#39;info&#39;</strong>:</p>
<ul>
<li><code>emergency</code>: system is unusable</li>
<li><code>alert</code>: action must be taken immediately</li>
<li><code>critical</code>: the system is in critical condition</li>
<li><code>error</code>: error condition</li>
<li><code>warning</code>: warning condition</li>
<li><code>notice</code>: a normal but significant condition</li>
<li><code>info</code>: a purely informational message</li>
<li><code>debug</code>: messages to debug an application</li>
</ul>
<p>Do it either in <a href="#environment">your <code>.env</code></a>:</p>
<pre><code>LOG=info
</code></pre><p>Or as a parameter to the main function:</p>
<pre><code class="lang-js">server({ log: &#39;info&#39; });
</code></pre>
<h3 id="core">Core</h3>
<blockquote>
<p>Experimental</p>
</blockquote>
<p>This is actually part of an internal plugin, so <a href="https://github.com/franciscop/server/issues/1">the specification of them is still experimental</a>. However the options <em>will</em> be accepted like this: an object with the key the same as the plugin name and the options as an object like this:</p>
<pre><code class="lang-js">server({
  core: {
    csrf: {
      ignoreMethods: [&#39;GET&#39;, &#39;HEAD&#39;, &#39;OPTIONS&#39;],
      value: req =&gt; req.body.csnowflakerf
    }
  }
});
</code></pre>
<p>The name for the <code>.env</code> file is still undecided, but the standard will probably be <code>PLUGINNAME_OPTION=value</code>. For the example above:</p>
<pre><code>CORE_CSR=false
</code></pre><p>You can modify many of the middleware in this way</p>
<h2 id="middleware">Middleware</h2>
<p>A <em>server middleware</em> is a function that will be called on each request. It accepts <a href="#context">a context object</a> and <a href="#asynchronous-return">returns a promise</a> for asynchronous methods or <a href="#synchronous-return">something else</a> for synchronous methods. A couple of examples:</p>
<pre><code class="lang-js">const setname = ctx =&gt; { ctx.req.user = &#39;Francisco&#39;; };
const sendname = ctx =&gt; ctx.req.user;
server(setname, sendname);
</code></pre>
<p>We are using the latest version of Javascript (ES7) that provides many useful options.</p>
<blockquote>
<p>Note: if you resolve it with a function, this will be called with <code>ctx</code>. This is not so useful for normal devs, but it is for server contributions. See <a href="../advanced/">advanced configuration</a>.</p>
</blockquote>
<h2 id="context">Context</h2>
<p>Context is the only parameter that middleware receives and we&#39;ll call it <code>ctx</code>. <strong>It represents all the information known at this point</strong>. It can appear at several points, but the most important one is as a middleware parameter.</p>
<p>In this situation it has, among others, the properties <code>req</code>, <code>res</code> (from express) and <code>options</code>:</p>
<pre><code class="lang-js">const middleware = ctx =&gt; {
  ctx.req;      // Request parameter, similar to `(req, res)` in express
  ctx.res;      // Response parameter, similar to `(req, res)` in express
  ctx.options;  // The options for the server instance
}
</code></pre>
<p>If you are developing a library or just want more advanced features, you should also have access to these:</p>
<pre><code class="lang-js">let middleware = ctx =&gt; {
  ctx.app;        // Current express instance
  ctx.server;     // The http-server instance
};
</code></pre>
<p>TODO: explain more about <code>req</code>, <code>res</code> and <code>options</code> (explanation for each and their methods and a link to express docs).</p>
<h2 id="synchronous">Synchronous</h2>
<p>A synchronous function is one that executes one line after another. To make your function synchronous you just have <a href="#asynchronous-return">not to make it asynchronous</a>, which means <em>do not return a promise</em>.</p>
<p>Most code is actually synchronous so let&#39;s see some examples:</p>
<pre><code class="lang-js">// Some simple logging
const middle1 = () =&gt; {
  console.log(&#39;Hello 世界&#39;);
};

// Asign a user to the context
const middle2 = ctx =&gt; {
  ctx.user = { name: &#39;Francisco&#39;, available: true };
};

// Make sure that there is a user
const middle3 = ctx =&gt; {
  if (!ctx.user) {
    throw new Error(&#39;No user detected!&#39;);
  }
};

// Send some info to the browser
const middle4 = ctx =&gt; {
  return `Some info for ${ctx.user.name}`;
};
</code></pre>
<h2 id="asynchronous">Asynchronous</h2>
<pre><code class="lang-js">// Asynchronous, find user with Mongoose (MongoDB)
const middle2 = async () =&gt; {
  const user = await user.find({ name: &#39;Francisco&#39; }).exec();
  console.log(user);
};
</code></pre>
<p>And how to use them:</p>
<pre><code class="lang-js">// Synchronous
server(() =&gt; {
  console.log(&#39;Hello 世界&#39;);
});

// Asynchronous
server(async () =&gt; {
  const user = await user.find({ name: &#39;Francisco&#39; }).exec();
  console.log(user);
});
</code></pre>
<h3 id="return-value">Return value</h3>
<p>If your middleware is going to be synchronous, you can just return the value to be sent to the browser:</p>
<pre><code class="lang-js">// Send a string
const middle = ctx =&gt; &#39;Hello 世界&#39;;

// Send a JSON
const middle = ctx =&gt; [&#39;hello&#39;, &#39;世界&#39;];
const middle = ctx =&gt; ({ hello: &#39;世界&#39; });
// Note: extra parenthesis not to be confused with arrow fn

// Send a status code
const middle = ctx =&gt; 404;
</code></pre>
<p>In sync mode you can throw anything to trigger an error:</p>
<pre><code class="lang-js">const { error } = server.router;

let middle = ({ req }) =&gt; {
  if (!req.body) {
    throw new Error(&#39;No body provided&#39;);
  }
}

server(middle, error(ctx =&gt; {
  console.log(ctx.error);
}));
</code></pre>
<p>When you want to handle code asynchronously you should return a promise. Then it will continue the middleware chain as it is resolved, or skip it as it is rejected:</p>
<pre><code class="lang-js">const middle = async ctx =&gt; {
  if (!req.body) {
    throw new Error(&#39;No body provided&#39;);
  }
});
</code></pre>
<h2 id="express-middleware">Express middleware</h2>
<p>Modern is a small utility that allows you to use express middleware within <code>server</code>. The proper way of using <code>modern</code> is:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
const { modern } = server.utils;
const oldCookieParser = require(&#39;cookie-parser&#39;)({ ... });
const cookieParser = server.modern(oldCookieParser);

// TODO: cancel the old cookieparser
server(cookieParser, ...);
</code></pre>
<!-- // DEPRECATED:





One of the most powerful things from express and thus from `server` is the Middleware. We extended it by setting some default, useful middleware, but we wanted to also give you the flexibility to edit this.

> We recommend adding your own middleware to a folder in your project called `/middle`, and all examples below will make this assumption.

There are four ways of loading middleware with `server`: as a string, as a function, as an array or as an object. They are all explained below. The most important difference is named (object) vs unnamed (others) middleware, as only named middleware will overwrite the defaults.

### String

This is the simplest way to add middleware, it will just require() that string. This is not so useful with some packages since they require an additional function call (such as `require('body-parser')()`), however it's perfect for your own middleware:

```js
// Load the middleware 'body-parser' from the folder '/middle'
server(3000, './middle/body-parser.js');
```

Then inside that `./middle/body-parser.js`:

```js
module.exports = function(req, res, next) {

  // do your thing here

  next();
}
```

### Function

Middleware *is* a function that accepts `(req, res, next)` (or `(err, req, res, next)` parameters, so all other methods are ultimately converted to this one. Read more just by googling' "express middleware" or "write middleware express".

As a simple example, there are many pre-packaged modules, so let's see one example where we imagine that `body-parser` is not loaded by default:

```js
// Include bodyparser in your file
let bodyparser = require('body-parser')({ extended: true });

// Load it as middleware
server(3000, bodyparser);
```

### Array

This will be converted to a series of functions, and inside the array there can be any of the other types. It is useful to bundle them by category:

```js
let parsers = [
  // ...
];

let { get, post } = server.router;
let routes = [
  get('/', (req, res) => { /* ... */ }),
  post('/', (req, res) => { /* ... */ })
];

server(3000, parsers, routes);
```

### Object

You can name them, and they will **replace one of the default middlewares if the name matches it**. Let's go with the simple example of `body-parser`:

```js
const server = require('server');

// Uses body-parser
server(3000);

// Don't use body-parser
server(3000, { bodyparser: false });

// Use a different body-parser
server(3000, { bodyparser: coolerBodyParser() });
``` -->
<h2 id="router">Router</h2>
<p>A router is a function that creates <em>route(s)</em>, which in turns tell the server how to handle each request. They are a specific kind of middleware that wraps your logic and acts as a gateway to it:</p>
<pre><code class="lang-js">// Plain middleware for ANY request (NOT a router)
const all = ctx =&gt; { /* ... */ };

// Create a GET route for the users page
const users = get(&#39;/users&#39;, ctx =&gt; { /* ... */ })
</code></pre>
<p>The <code>ctx</code> variable is <a href="https://serverjs.io/documentation/middleware/#context">explained in the middleware documentation</a>. One important difference between the routes and middleware is that <a href="#routes-are-final"><strong>all routes are final</strong></a>. This means that <strong>each request will use one route at most</strong>.</p>
<p>All of the routers reside within the <code>server.router</code> and follow this structure:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
const { NAME } = server.router;
const doSomething = NAME(ID, fn1, [fn2], [fn3]);
server(doSomething);
</code></pre>
<h2 id="rest">REST</h2>
<p>The <a href="http://stackoverflow.com/q/671118/938236">basic REST routers</a> are present: <code>get</code>, <code>post</code>, <code>put</code>, <code>del</code>. Delete is called <code>del</code> since &#39;delete&#39; is a reserved word in Javascript. This is the recommended way of importing the routers with destructuring:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
const { get, post, put, del } = server.router;
</code></pre>
<blockquote>
<p>TODO: split this into a tutorial as I couldn&#39;t find any decent one for this:</p>
</blockquote>
<p>They all <a href="http://expressjs.com/en/4x/api.html#router">accept a path in a similar way to Express.js</a> as ID, which will be parametrized:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
const { get } = server.router;

// Homepage
get(&#39;/&#39;, ctx =&gt; { /* ... */ });

// A specific page
get(&#39;/users&#39;, ctx =&gt; { /* ... */ });

// Any page such as /contact, /users, /125, etc
get(&#39;/:page&#39;, ctx =&gt; { /* ... */ });
</code></pre>
<h3 id="simple-router">Simple router</h3>
<p>To define a simple router, you could do:</p>
<pre><code class="lang-js">const server = require(&#39;server&#39;);

// Import methods &#39;get&#39; and &#39;post&#39; from the router
const { get, post } = server.router;

server(
  get(&#39;/users&#39;, ctx =&gt; { /* ... */ }),
  post(&#39;/users&#39;, ctx =&gt; { /* ... */ })
);
</code></pre>
<h3 id="complex-router">Complex router</h3>
<p>If you are going to have many routes, we recommend splitting it into a separated file, either in the root of the project as <code>routes.js</code> or in a different place:</p>
<pre><code class="lang-js">// app.js
const server = require(&#39;server&#39;);
const routes = require(&#39;./routes&#39;);

server(routes);
</code></pre>
<pre><code class="lang-js">// routes.js
const { get, post } = require(&#39;server&#39;).router;
const ctrl = require(&#39;auto-load&#39;)(&#39;controllers&#39;);

// You can simply export an array of routes
module.exports = [
  get(&#39;/&#39;, ctrl.home.index),
  get(&#39;/users&#39;, ctrl.users.index),
  post(&#39;/users&#39;, ctrl.users.add),
  get(&#39;/photos&#39;, ctrl.photos.index),
  post(&#39;/photos&#39;, ctrl.photos.add),
  ...
];
</code></pre>
<h2 id="error">Error</h2>
<blockquote>
<p>Explain about the router error: <code>const { error } = server.router;</code> and how it handles the errors thrown: <code>throw new Error()</code> || <code>ctx.throw(&#39;test:a&#39;)?</code></p>
</blockquote>
<h2 id="websockets">Websockets</h2>
<blockquote>
<p><em>Not yet available, coming in version 1.1</em></p>
</blockquote>
<pre><code class="lang-js">const server = require(&#39;server&#39;);
let { get, socket } = server.router;

server({}, [
  get(&#39;/&#39;, (req, res) =&gt; res.sendFile(__dirname + &#39;/public/index.html&#39;)),
  socket(&#39;message&#39;, (data, socket, io) =&gt; {
    io.emit(data);
  })
]);
</code></pre>
<h2 id="retrocompatibility">Retrocompatibility</h2>
<blockquote>
<p>Explain about the wrapper for all the middleware out there</p>
</blockquote>
<h2 id="routes-are-final">Routes are final</h2>
<blockquote>
<p>Explain how a route is matched only once</p>
</blockquote>
<h2 id="advanced">Advanced</h2>
<p>Some of the concepts that you won&#39;t find day-to-day but that might be useful when debugging, creating your own libraries or contributing to server.</p>
<h2 id="creating-middleware">Creating middleware</h2>
<p>While <em>plugins are not yet available</em> you can create middleware just fine and it should be able to cover most developer needs.</p>
<h2 id="join-routes">Join routes</h2>
<p>If you have two routers and want to make it into one for any reason, you can do so through a helper function we created.</p>
<pre><code class="lang-js">let { get, post, join } = server.router;

let routes = join(
  get(&#39;/&#39;, home.index),
  get(&#39;/users&#39;, users.index),
  // ...
);

server({}, acceptsOnlyASingleRoute(routes));
</code></pre>
<!--
## Experimental

> To enable these, you'll have to add an `EXPERIMENTAL=1` to your environment variables. No need to say that this is not stable and not part of the stable API.

There's an experimental way of dealing with those:

```js
server([
  get('/about.html').file('public/about.html'),
  get('/non-existing').status(404).send('Error 404!'),
  get('/').send('Hello 世界')
]);
```

They are the same methods as in [Express Methods](http://expressjs.com/en/api.html#res.methods) and accept the same parameters (adding `file`, which is an alias of `sendFile`, and removing `get` and `set` as it conflicts with `Router.get` and `Router.set`). The ones that *do not send* a response can be concatenated, while the ones that send a response will be ignored. So the second *send* will be ignored:

```js
server([
  get('/').status(200).send('Hi there').send('I am ignored')
]);
```
-->
<h2 id="promise">Promise</h2>
<p>The main function returns a promise which will be fulfilled when the server is launched or might throw an initialization error such as port is already in use.</p>
<p>It gets passed the <code>ctx</code> object, just without the request-specific parameters (not including <code>req</code> and <code>res</code> among others). It does include:</p>
<ul>
<li><code>app</code>: the express instance</li>
<li><code>server</code>: the original <code>http-server</code></li>
<li><code>express</code>: the express required as in <code>require(&#39;express&#39;)</code></li>
</ul>
<p>Also, it will transparently use the <code>http-server</code> whether possible (through ES6&#39;s Proxy), so function calls such as <code>.close()</code> work straight on the instance:</p>
<pre><code class="lang-js">server().then(ctx =&gt; {

  // Run the server for a single second then close it
  setTimeout(() =&gt; ctx.close(), 1000);
}).catch(error =&gt; {
  console.log(&quot;There was an error:&quot;, error);
});
</code></pre>
<p>For most purposes you can just launch the server ignoring the return value:</p>
<pre><code class="lang-js">server();
</code></pre>
<p>This might be useful for error-handling, debugging and testing (see the tests in the folder <code>tests</code>) or extending server&#39;s functionality.</p>
<h3 id="included-modules">Included modules</h3>
<p>This is the default included middleware, which can also be seen in <code>plugins/parse</code> and <code>plugins/connect</code>:</p>
<ul>
<li><a href="https://www.npmjs.com/package/dotenv"><code>dotenv</code></a></li>
<li><code>bodyParser</code> : <a href="https://www.npmjs.com/package/body-parser"><code>body-parser</code></a></li>
<li><code>jsonParser</code> : <a href="https://www.npmjs.com/package/body-parser"><code>body-parser</code></a></li>
<li><code>dataParser</code> : <a href="https://www.npmjs.com/package/express-data-parser"><code>express-data-parser</code></a></li>
<li><code>compress</code> : <a href="https://www.npmjs.com/package/compression"><code>compression</code></a></li>
<li><code>cookieParser</code> : <a href="https://www.npmjs.com/package/cookie-parser"><code>cookie-parser</code></a></li>
<li><code>session</code> : <a href="https://www.npmjs.com/package/express-session"><code>express-session</code></a></li>
<li><code>favicon</code> : <a href="https://www.npmjs.com/package/serve-favicon"><code>serve-favicon</code></a></li>
<li><code>responseTime</code> : <a href="https://www.npmjs.com/package/response-time"><code>response-time</code></a></li>
<li><code>methodOverride</code> : <a href="https://www.npmjs.com/package/method-override"><code>method-override</code></a></li>
</ul>
</div></div></article><script src="https://unpkg.com/paperdocs@1.0.9/paperdocs.min.js"></script><script>// Avoid email scrapping
setTimeout(function() {
  var email = 'mailto:public' + '@francisco.i' + 'o?subject=server.js';
  [].slice.call(document.querySelectorAll('a.email')).forEach(function(el){
    el.setAttribute('href', email);
  });
}, 2000);

// Add language tag to the code for print
[].slice.call(document.querySelectorAll('pre code')).filter(function(pre){
  return /lang(uage)?\-/.test(pre.className);
}).forEach(function(pre){
  var name = pre.className.split(/\s+/).filter(function(name){
    return /lang(uage)?\-/.test(name);
  })[0].replace(/lang(uage)?\-/, '');
  var map = { js: 'javascript', jade: 'pug' };
  if (name in map) name = map[name];
  pre.parentNode.setAttribute('data-language', name);
});


var nav = u('nav');
var toc = u('.toc');
var navheight = parseFloat(getComputedStyle(u('nav').first()).getPropertyValue('height'));
if (toc.length && window.innerWidth > 900) {
  u('nav').addClass('wide');
  u('[href="' + window.location.pathname + '"]').parent().addClass('active');
  var articlepaddingtop = parseFloat(getComputedStyle(u('article.documentation').first()).getPropertyValue('padding-top'));
  var h2paddingtop = parseFloat(getComputedStyle(u('.toc h2').first()).getPropertyValue('padding-top'));
  u('.toc').first().style.top = (articlepaddingtop + navheight - 20) + 'px';
  u('.toc').first().style.maxHeight = 'calc(100% - ' + (articlepaddingtop + navheight + 10) + 'px)';
  u('.toc').first().style.width = (parseFloat(getComputedStyle(u('.toc').parent().first()).getPropertyValue('width')) - 20) + 'px';
} else { toc = ''; }

function transparency(){
  var top = document.documentElement.scrollTop || document.body.scrollTop;
  var height = "innerHeight" in window
    ? window.innerHeight
    : document.documentElement.offsetHeight;

  if (top > 80) {
    if (nav.hasClass('transparent')) {
      nav.removeClass('transparent');
    }
  } else {
    if (!nav.hasClass('transparent')) {
      nav.addClass('transparent');
    }
  }

  if (toc.length) {
    toc.toggleClass('fixed', u('article.documentation').size().top < navheight - 20);
  }
}
u(document).on('scroll', transparency);
transparency();
setTimeout(function(){ nav.removeClass('instant'); }, 200);


// Remove an incorrect "get" that there was highlighted
Prism.hooks.add('after-highlight', function(env){
  u('span.token.keyword').filter(el => el.innerHTML === 'get').replace('get');
});

u('.toc .more').handle('click', e => {
  const container = u(e.currentTarget).closest('li');
	const child = container.find('ul').nodes[0];
  const height = container.hasClass('active') ? 0 : child.scrollHeight;
  child.style.maxHeight = height + 'px';
  container.toggleClass('active');
});

u('.toc a').on('click', e => {
  const href = u(e.currentTarget).attr('href');
  if (!href) return;
  const hash = href.split('#')[1];
  if (href && u('#' + hash).length) {
    e.preventDefault();
    u('#' + hash).scroll();
  }
});



// Google analytics
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63739359-2', 'auto');
ga('send', 'pageview');
</script></body></html>